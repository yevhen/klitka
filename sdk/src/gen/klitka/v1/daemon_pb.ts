// @generated by protoc-gen-es v1.10.1 with parameter "target=ts,import_extension=none"
// @generated from file klitka/v1/daemon.proto (package klitka.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";

/**
 * @generated from enum klitka.v1.SecretFormat
 */
export enum SecretFormat {
  /**
   * @generated from enum value: SECRET_FORMAT_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: SECRET_FORMAT_BEARER = 1;
   */
  BEARER = 1,

  /**
   * @generated from enum value: SECRET_FORMAT_RAW = 2;
   */
  RAW = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(SecretFormat)
proto3.util.setEnumType(SecretFormat, "klitka.v1.SecretFormat", [
  { no: 0, name: "SECRET_FORMAT_UNSPECIFIED" },
  { no: 1, name: "SECRET_FORMAT_BEARER" },
  { no: 2, name: "SECRET_FORMAT_RAW" },
]);

/**
 * @generated from enum klitka.v1.MountMode
 */
export enum MountMode {
  /**
   * @generated from enum value: MOUNT_MODE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: MOUNT_MODE_RO = 1;
   */
  RO = 1,

  /**
   * @generated from enum value: MOUNT_MODE_RW = 2;
   */
  RW = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(MountMode)
proto3.util.setEnumType(MountMode, "klitka.v1.MountMode", [
  { no: 0, name: "MOUNT_MODE_UNSPECIFIED" },
  { no: 1, name: "MOUNT_MODE_RO" },
  { no: 2, name: "MOUNT_MODE_RW" },
]);

/**
 * @generated from message klitka.v1.StartVMRequest
 */
export class StartVMRequest extends Message<StartVMRequest> {
  /**
   * @generated from field: repeated klitka.v1.Mount mounts = 1;
   */
  mounts: Mount[] = [];

  /**
   * @generated from field: klitka.v1.NetworkPolicy network = 2;
   */
  network?: NetworkPolicy;

  /**
   * @generated from field: repeated klitka.v1.Secret secrets = 3;
   */
  secrets: Secret[] = [];

  constructor(data?: PartialMessage<StartVMRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "klitka.v1.StartVMRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "mounts", kind: "message", T: Mount, repeated: true },
    { no: 2, name: "network", kind: "message", T: NetworkPolicy },
    { no: 3, name: "secrets", kind: "message", T: Secret, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StartVMRequest {
    return new StartVMRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StartVMRequest {
    return new StartVMRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StartVMRequest {
    return new StartVMRequest().fromJsonString(jsonString, options);
  }

  static equals(a: StartVMRequest | PlainMessage<StartVMRequest> | undefined, b: StartVMRequest | PlainMessage<StartVMRequest> | undefined): boolean {
    return proto3.util.equals(StartVMRequest, a, b);
  }
}

/**
 * @generated from message klitka.v1.NetworkPolicy
 */
export class NetworkPolicy extends Message<NetworkPolicy> {
  /**
   * @generated from field: repeated string allow_hosts = 1;
   */
  allowHosts: string[] = [];

  /**
   * @generated from field: repeated string deny_hosts = 2;
   */
  denyHosts: string[] = [];

  /**
   * @generated from field: bool block_private_ranges = 3;
   */
  blockPrivateRanges = false;

  constructor(data?: PartialMessage<NetworkPolicy>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "klitka.v1.NetworkPolicy";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "allow_hosts", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "deny_hosts", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "block_private_ranges", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NetworkPolicy {
    return new NetworkPolicy().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NetworkPolicy {
    return new NetworkPolicy().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NetworkPolicy {
    return new NetworkPolicy().fromJsonString(jsonString, options);
  }

  static equals(a: NetworkPolicy | PlainMessage<NetworkPolicy> | undefined, b: NetworkPolicy | PlainMessage<NetworkPolicy> | undefined): boolean {
    return proto3.util.equals(NetworkPolicy, a, b);
  }
}

/**
 * @generated from message klitka.v1.Secret
 */
export class Secret extends Message<Secret> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from field: repeated string hosts = 2;
   */
  hosts: string[] = [];

  /**
   * @generated from field: string value = 3;
   */
  value = "";

  /**
   * @generated from field: string header = 4;
   */
  header = "";

  /**
   * @generated from field: klitka.v1.SecretFormat format = 5;
   */
  format = SecretFormat.UNSPECIFIED;

  constructor(data?: PartialMessage<Secret>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "klitka.v1.Secret";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "hosts", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "header", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "format", kind: "enum", T: proto3.getEnumType(SecretFormat) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Secret {
    return new Secret().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Secret {
    return new Secret().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Secret {
    return new Secret().fromJsonString(jsonString, options);
  }

  static equals(a: Secret | PlainMessage<Secret> | undefined, b: Secret | PlainMessage<Secret> | undefined): boolean {
    return proto3.util.equals(Secret, a, b);
  }
}

/**
 * @generated from message klitka.v1.Mount
 */
export class Mount extends Message<Mount> {
  /**
   * @generated from field: string guest_path = 1;
   */
  guestPath = "";

  /**
   * @generated from field: string host_path = 2;
   */
  hostPath = "";

  /**
   * @generated from field: klitka.v1.MountMode mode = 3;
   */
  mode = MountMode.UNSPECIFIED;

  constructor(data?: PartialMessage<Mount>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "klitka.v1.Mount";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "guest_path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "host_path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "mode", kind: "enum", T: proto3.getEnumType(MountMode) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Mount {
    return new Mount().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Mount {
    return new Mount().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Mount {
    return new Mount().fromJsonString(jsonString, options);
  }

  static equals(a: Mount | PlainMessage<Mount> | undefined, b: Mount | PlainMessage<Mount> | undefined): boolean {
    return proto3.util.equals(Mount, a, b);
  }
}

/**
 * @generated from message klitka.v1.StartVMResponse
 */
export class StartVMResponse extends Message<StartVMResponse> {
  /**
   * @generated from field: string vm_id = 1;
   */
  vmId = "";

  constructor(data?: PartialMessage<StartVMResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "klitka.v1.StartVMResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "vm_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StartVMResponse {
    return new StartVMResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StartVMResponse {
    return new StartVMResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StartVMResponse {
    return new StartVMResponse().fromJsonString(jsonString, options);
  }

  static equals(a: StartVMResponse | PlainMessage<StartVMResponse> | undefined, b: StartVMResponse | PlainMessage<StartVMResponse> | undefined): boolean {
    return proto3.util.equals(StartVMResponse, a, b);
  }
}

/**
 * @generated from message klitka.v1.ExecRequest
 */
export class ExecRequest extends Message<ExecRequest> {
  /**
   * @generated from field: string vm_id = 1;
   */
  vmId = "";

  /**
   * @generated from field: string command = 2;
   */
  command = "";

  /**
   * @generated from field: repeated string args = 3;
   */
  args: string[] = [];

  constructor(data?: PartialMessage<ExecRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "klitka.v1.ExecRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "vm_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "command", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "args", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExecRequest {
    return new ExecRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExecRequest {
    return new ExecRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExecRequest {
    return new ExecRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ExecRequest | PlainMessage<ExecRequest> | undefined, b: ExecRequest | PlainMessage<ExecRequest> | undefined): boolean {
    return proto3.util.equals(ExecRequest, a, b);
  }
}

/**
 * @generated from message klitka.v1.ExecResponse
 */
export class ExecResponse extends Message<ExecResponse> {
  /**
   * @generated from field: int32 exit_code = 1;
   */
  exitCode = 0;

  /**
   * @generated from field: bytes stdout = 2;
   */
  stdout = new Uint8Array(0);

  /**
   * @generated from field: bytes stderr = 3;
   */
  stderr = new Uint8Array(0);

  constructor(data?: PartialMessage<ExecResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "klitka.v1.ExecResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "exit_code", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "stdout", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "stderr", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExecResponse {
    return new ExecResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExecResponse {
    return new ExecResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExecResponse {
    return new ExecResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ExecResponse | PlainMessage<ExecResponse> | undefined, b: ExecResponse | PlainMessage<ExecResponse> | undefined): boolean {
    return proto3.util.equals(ExecResponse, a, b);
  }
}

/**
 * @generated from message klitka.v1.ExecStreamRequest
 */
export class ExecStreamRequest extends Message<ExecStreamRequest> {
  /**
   * @generated from oneof klitka.v1.ExecStreamRequest.payload
   */
  payload: {
    /**
     * @generated from field: klitka.v1.ExecStart start = 1;
     */
    value: ExecStart;
    case: "start";
  } | {
    /**
     * @generated from field: klitka.v1.ExecInput input = 2;
     */
    value: ExecInput;
    case: "input";
  } | {
    /**
     * @generated from field: klitka.v1.PtyResize resize = 3;
     */
    value: PtyResize;
    case: "resize";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<ExecStreamRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "klitka.v1.ExecStreamRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "start", kind: "message", T: ExecStart, oneof: "payload" },
    { no: 2, name: "input", kind: "message", T: ExecInput, oneof: "payload" },
    { no: 3, name: "resize", kind: "message", T: PtyResize, oneof: "payload" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExecStreamRequest {
    return new ExecStreamRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExecStreamRequest {
    return new ExecStreamRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExecStreamRequest {
    return new ExecStreamRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ExecStreamRequest | PlainMessage<ExecStreamRequest> | undefined, b: ExecStreamRequest | PlainMessage<ExecStreamRequest> | undefined): boolean {
    return proto3.util.equals(ExecStreamRequest, a, b);
  }
}

/**
 * @generated from message klitka.v1.ExecStreamResponse
 */
export class ExecStreamResponse extends Message<ExecStreamResponse> {
  /**
   * @generated from oneof klitka.v1.ExecStreamResponse.payload
   */
  payload: {
    /**
     * @generated from field: klitka.v1.ExecOutput output = 1;
     */
    value: ExecOutput;
    case: "output";
  } | {
    /**
     * @generated from field: klitka.v1.ExecExit exit = 2;
     */
    value: ExecExit;
    case: "exit";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<ExecStreamResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "klitka.v1.ExecStreamResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "output", kind: "message", T: ExecOutput, oneof: "payload" },
    { no: 2, name: "exit", kind: "message", T: ExecExit, oneof: "payload" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExecStreamResponse {
    return new ExecStreamResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExecStreamResponse {
    return new ExecStreamResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExecStreamResponse {
    return new ExecStreamResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ExecStreamResponse | PlainMessage<ExecStreamResponse> | undefined, b: ExecStreamResponse | PlainMessage<ExecStreamResponse> | undefined): boolean {
    return proto3.util.equals(ExecStreamResponse, a, b);
  }
}

/**
 * @generated from message klitka.v1.ExecStart
 */
export class ExecStart extends Message<ExecStart> {
  /**
   * @generated from field: string vm_id = 1;
   */
  vmId = "";

  /**
   * @generated from field: string command = 2;
   */
  command = "";

  /**
   * @generated from field: repeated string args = 3;
   */
  args: string[] = [];

  /**
   * @generated from field: bool pty = 4;
   */
  pty = false;

  constructor(data?: PartialMessage<ExecStart>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "klitka.v1.ExecStart";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "vm_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "command", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "args", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "pty", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExecStart {
    return new ExecStart().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExecStart {
    return new ExecStart().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExecStart {
    return new ExecStart().fromJsonString(jsonString, options);
  }

  static equals(a: ExecStart | PlainMessage<ExecStart> | undefined, b: ExecStart | PlainMessage<ExecStart> | undefined): boolean {
    return proto3.util.equals(ExecStart, a, b);
  }
}

/**
 * @generated from message klitka.v1.ExecInput
 */
export class ExecInput extends Message<ExecInput> {
  /**
   * @generated from field: bytes data = 1;
   */
  data = new Uint8Array(0);

  /**
   * @generated from field: bool eof = 2;
   */
  eof = false;

  constructor(data?: PartialMessage<ExecInput>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "klitka.v1.ExecInput";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "data", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "eof", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExecInput {
    return new ExecInput().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExecInput {
    return new ExecInput().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExecInput {
    return new ExecInput().fromJsonString(jsonString, options);
  }

  static equals(a: ExecInput | PlainMessage<ExecInput> | undefined, b: ExecInput | PlainMessage<ExecInput> | undefined): boolean {
    return proto3.util.equals(ExecInput, a, b);
  }
}

/**
 * @generated from message klitka.v1.PtyResize
 */
export class PtyResize extends Message<PtyResize> {
  /**
   * @generated from field: uint32 rows = 1;
   */
  rows = 0;

  /**
   * @generated from field: uint32 cols = 2;
   */
  cols = 0;

  constructor(data?: PartialMessage<PtyResize>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "klitka.v1.PtyResize";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "rows", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "cols", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PtyResize {
    return new PtyResize().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PtyResize {
    return new PtyResize().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PtyResize {
    return new PtyResize().fromJsonString(jsonString, options);
  }

  static equals(a: PtyResize | PlainMessage<PtyResize> | undefined, b: PtyResize | PlainMessage<PtyResize> | undefined): boolean {
    return proto3.util.equals(PtyResize, a, b);
  }
}

/**
 * @generated from message klitka.v1.ExecOutput
 */
export class ExecOutput extends Message<ExecOutput> {
  /**
   * stdout | stderr
   *
   * @generated from field: string stream = 1;
   */
  stream = "";

  /**
   * @generated from field: bytes data = 2;
   */
  data = new Uint8Array(0);

  constructor(data?: PartialMessage<ExecOutput>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "klitka.v1.ExecOutput";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "stream", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "data", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExecOutput {
    return new ExecOutput().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExecOutput {
    return new ExecOutput().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExecOutput {
    return new ExecOutput().fromJsonString(jsonString, options);
  }

  static equals(a: ExecOutput | PlainMessage<ExecOutput> | undefined, b: ExecOutput | PlainMessage<ExecOutput> | undefined): boolean {
    return proto3.util.equals(ExecOutput, a, b);
  }
}

/**
 * @generated from message klitka.v1.ExecExit
 */
export class ExecExit extends Message<ExecExit> {
  /**
   * @generated from field: int32 exit_code = 1;
   */
  exitCode = 0;

  constructor(data?: PartialMessage<ExecExit>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "klitka.v1.ExecExit";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "exit_code", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExecExit {
    return new ExecExit().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExecExit {
    return new ExecExit().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExecExit {
    return new ExecExit().fromJsonString(jsonString, options);
  }

  static equals(a: ExecExit | PlainMessage<ExecExit> | undefined, b: ExecExit | PlainMessage<ExecExit> | undefined): boolean {
    return proto3.util.equals(ExecExit, a, b);
  }
}

/**
 * @generated from message klitka.v1.StopVMRequest
 */
export class StopVMRequest extends Message<StopVMRequest> {
  /**
   * @generated from field: string vm_id = 1;
   */
  vmId = "";

  constructor(data?: PartialMessage<StopVMRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "klitka.v1.StopVMRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "vm_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StopVMRequest {
    return new StopVMRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StopVMRequest {
    return new StopVMRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StopVMRequest {
    return new StopVMRequest().fromJsonString(jsonString, options);
  }

  static equals(a: StopVMRequest | PlainMessage<StopVMRequest> | undefined, b: StopVMRequest | PlainMessage<StopVMRequest> | undefined): boolean {
    return proto3.util.equals(StopVMRequest, a, b);
  }
}

/**
 * @generated from message klitka.v1.StopVMResponse
 */
export class StopVMResponse extends Message<StopVMResponse> {
  constructor(data?: PartialMessage<StopVMResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "klitka.v1.StopVMResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StopVMResponse {
    return new StopVMResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StopVMResponse {
    return new StopVMResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StopVMResponse {
    return new StopVMResponse().fromJsonString(jsonString, options);
  }

  static equals(a: StopVMResponse | PlainMessage<StopVMResponse> | undefined, b: StopVMResponse | PlainMessage<StopVMResponse> | undefined): boolean {
    return proto3.util.equals(StopVMResponse, a, b);
  }
}

