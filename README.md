# klitka

Local Linux microVM runtime with policy-controlled networking and filesystem access.

`klitka` provides a sandbox environment for executing untrusted code—such as code generated by AI agents—inside lightweight microVMs. It manages the hypervisor lifecycle, enforces network egress policies, and handles secure filesystem mounts via a central daemon.

## Architecture and Inspiration

`klitka` was inspired by [Gondolin](https://github.com/earendil-works/gondolin), which demonstrated the power of programmable local microVMs for AI agents. 

While Gondolin implements its network and filesystem stacks in JavaScript for maximum flexibility, `klitka` explores a different trade-off. We focus on leveraging established system tools and a client-server architecture:

*   **Daemon-based Control Plane:** A long-lived Go daemon (`klitka-daemon`) manages the VM fleet. This allows multiple SDK clients to connect to the same environments and ensures resources are cleaned up even if the parent application crashes.
*   **Standard System Interfaces:** Instead of a custom network stack, `klitka` uses standard TAP/VMNet interfaces and a high-performance Go-based MITM proxy. 
*   **Virtiofs Support:** Filesystem sharing is handled by `virtiofsd`, providing near-native I/O performance and robust enforcement of read-only/read-write permissions.
*   **Connect Protocol:** All communication between the SDK/CLI and the daemon happens over a Protobuf/Connect API, making it easy to build clients in any language.

## TypeScript SDK Usage

```typescript
import { Sandbox } from "@klitka/sdk";

const vm = await Sandbox.start({
  fs: {
    mounts: [
      { hostPath: "./workspace", guestPath: "/data", mode: "rw" }
    ]
  },
  network: {
    allowHosts: ["api.github.com", "api.openai.com"],
    blockPrivateRanges: true
  },
  secrets: {
    GITHUB_TOKEN: {
      hosts: ["api.github.com"],
      value: process.env.GITHUB_TOKEN!
    }
  }
});

// Execute a command and buffer the result
const { exitCode, stdout } = await vm.exec("ls -la /data");

// Or use a streaming session for interactive work
const session = await vm.shell();
session.write(new TextEncoder().encode("echo 'hello'\n"));

await vm.close();
```

## Key Components

### klitka-daemon (Go)
The core service that manages VM instances (QEMU), wires up networking via a local MITM proxy, and configures `virtiofsd` for filesystem access. It exposes a ConnectRPC interface over a local Unix socket or TCP.

### klitka CLI (Go)
A thin wrapper around the daemon's API that allows starting, stopping, and executing commands in sandboxes from the terminal.

### @klitka/sdk (TypeScript)
A high-level client library for Node.js applications. It handles the connection to the daemon and provides an ergonomic API for sandbox lifecycle management.

### sandboxd (Zig)
A minimal agent running inside the guest microVM that handles process execution and I/O over `virtio-serial`.

## Security Features

*   **Network Isolation:** Default-deny policy for all non-whitelisted traffic. HTTP/HTTPS traffic is proxied and can be inspected or modified by the host.
*   **DNS Guard:** Prevents DNS rebinding attacks by resolving and verifying IP addresses on the host before they reach the guest.
*   **Secret Masking:** Sensitive credentials (like API keys) are injected at the network proxy layer. The guest environment only sees placeholder values, making it harder for untrusted code to exfiltrate real secrets.
*   **Filesystem Boundary:** No host files are accessible to the guest unless explicitly mounted.

## Platform Support

*   **macOS:** QEMU with Hypervisor.framework (HVF).
*   **Linux:** QEMU with KVM.
*   **Windows:** Integration via WSL2 (the daemon runs inside a WSL2 distribution, while the Windows CLI/SDK connects to it over a local TCP port).

## Development

`klitka` uses Nix to manage its development environment. See [CONTRIBUTING.md](CONTRIBUTING.md) for details on building the guest image, running tests, and project conventions.
